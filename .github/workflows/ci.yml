# .github/workflows/ci.yml
name: Build and Test

on:
  push:
    branches: [ main, master, develop, "feature/**" ]  # Runs on main release and feature branches
    tags: [ 'v*.*.*' ]  # Ensure CI runs for version tags too
  pull_request:
    branches: [ main, master, develop ]  # Also runs on PRs to main/master/develop
  workflow_dispatch:  # Allow manual triggering

env:
  RELEASE_VERSION: '1.0.0'

  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  DOTNET_VERSION: '10.0.x'
  JAVA_VERSION: '17'

jobs:
  validate-workflows:
    name: Validate Workflow Syntax
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate GitHub Actions workflows
      run: |
        set -euo pipefail

        echo "ðŸ“‹ Installing actionlint for workflow validation..."
        mkdir -p /tmp/actionlint
        cd /tmp/actionlint

        # Download the official installer script and run it
        curl -sSfL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash | bash

        # Ensure the binary is executable
        chmod +x ./actionlint
        echo "âœ… Actionlint installed"

        echo "ðŸ“ Validating workflow files..."
        # Assume we're already in the GitHub workspace; if not, uncomment the next line:
        # cd "$GITHUB_WORKSPACE"

        WORKFLOW_DIR=".github/workflows"

        # Optional: check existence to provide a friendly message
        if [ ! -d "$WORKFLOW_DIR" ]; then
          echo "â„¹ï¸ No workflows directory found at $WORKFLOW_DIR. Skipping validation."
          exit 0
        fi

        # Run actionlint directly on the workflows directory (recursively)
        # This covers both .yml and .yaml automatically.
        if /tmp/actionlint/actionlint -color always "$WORKFLOW_DIR"; then
          echo "âœ… All workflows are syntactically valid"
        else
          echo "âŒ Workflow validation failed"
          exit 1

  scan-dependencies:
    name: Scan for Vulnerable Dependencies
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Detect project type
      id: detect
      run: |
        project_type="unknown"

        if [[ -f "package.json" ]]; then
          project_type="node"
        elif [[ -f "requirements.txt" || -f "pyproject.toml" ]]; then
          project_type="python"
        elif find . -type f -name "*.csproj" -print -quit | grep -q .; then
          project_type="dotnet"
        elif find . \
          -type d \( -name ".git" -o -name "node_modules" -o -name "build" -o -name ".gradle" \) -prune -false -o \
          -type f \( -name "pom.xml" -o -name "build.gradle" -o -name "build.gradle.kts" \) \
          -print -quit | grep -q .; then
          project_type="java"
        fi

        # Write to GitHub Actions output if available; otherwise print to stdout for local testing
        if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
          printf "project_type=%s\n" "$project_type" >> "$GITHUB_OUTPUT"
        else
          printf "project_type=%s\n" "$project_type"
        fi

    # Node.js vulnerability scanning
    - name: Run npm audit (Node.js)
      if: ${{ steps.detect.outputs.project_type == 'node' }}
      run: |
        echo "ðŸ” Scanning Node.js dependencies for vulnerabilities..."
        npm audit --audit-level=moderate || {
          echo "âš ï¸  Vulnerabilities found. Run 'npm audit fix' to resolve."
          exit 1
        }

    # Python vulnerability scanning
    - name: Run pip-audit (Python)
      if: ${{ steps.detect.outputs.project_type == 'python' }}
      run: |
        echo "ðŸ” Scanning Python dependencies for vulnerabilities..."
        pip install pip-audit > /dev/null 2>&1
        pip-audit --desc || echo "âš ï¸  Review vulnerabilities above"

    # .NET vulnerability scanning
    - name: Run dotnet list package (dotnet)
      if: ${{ steps.detect.outputs.project_type == 'dotnet' }}
      run: |
        echo "ðŸ” Scanning .NET dependencies for vulnerabilities..."
        dotnet tool install --global dotnet-outdated-tool > /dev/null 2>&1 || true
        dotnet outdated || echo "âš ï¸  Review outdated packages above"

    # Java vulnerability scanning
    - name: Run dependency-check (Java)
      if: ${{ steps.detect.outputs.project_type == 'java' }}
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'Java Project'
        path: '.'
        format: 'JSON'
        args: >
          --enableExperimental
      continue-on-error: true

  build-test:
    name: Build and Test
    needs: [validate-workflows, scan-dependencies]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Detect project type
    - name: Detect project type
      id: detect
      run: |
        project_type="unknown"

        if [[ -f "package.json" ]]; then
          project_type="node"
        elif [[ -f "requirements.txt" || -f "pyproject.toml" ]]; then
          project_type="python"
        elif find . -type f -name "*.csproj" -print -quit | grep -q .; then
          project_type="dotnet"
        elif find . \
          -type d \( -name ".git" -o -name "node_modules" -o -name "build" -o -name ".gradle" \) -prune -false -o \
          -type f \( -name "pom.xml" -o -name "build.gradle" -o -name "build.gradle.kts" \) \
          -print -quit | grep -q .; then
          project_type="java"
        fi

        # Write to GitHub Actions output if available; otherwise print to stdout for local testing
        if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
          printf "project_type=%s\n" "$project_type" >> "$GITHUB_OUTPUT"
        else
          printf "project_type=%s\n" "$project_type"
        fi

    # =============== Node.js ===============
    - name: Set up Node.js and cache npm
      if: steps.detect.outputs.project_type == 'node'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: |
          **/package-lock.json
          **/yarn.lock
          **/pnpm-lock.yaml

    # =============== Python ===============
    - name: Set up Python and cache pip
      if: steps.detect.outputs.project_type == 'python'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: |
          **/requirements.txt
          **/pyproject.toml
          **/setup.py
          **/poetry.lock

    # =============== .NET ===============
    - name: Set up .NET
      if: steps.detect.outputs.project_type == 'dotnet'
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # .NET projects benefit from caching the ~/.nuget/packages folder
    - name: Cache NuGet packages
      if: steps.detect.outputs.project_type == 'dotnet'
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/obj/project.assets.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    # =============== Java ===============
    - name: Set up Java and cache Maven/Gradle
      if: steps.detect.outputs.project_type == 'java'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: ${{ steps.detect.outputs.java_cache }}

    # =============== Install Dependencies ===============
    - name: Install dependencies
      run: |
        set -euo pipefail

        # Optional: echo the detected project type for diagnostics
        echo "Detected project type: '${{ steps.detect.outputs.project_type }}'"

        # Small helper for friendly errors
        die() { echo "âŒ Error: $*" >&2; exit 1; }

        # Check tool availability function
        need() { command -v "$1" >/dev/null 2>&1 || die "'$1' is required but not found in PATH"; }

        case "${{ steps.detect.outputs.project_type }}" in
          node)
            need npm
            if [[ ! -f "package.json" ]]; then
              die "package.json not found but project type is 'node'"
            fi
            # Use CI-appropriate install; respects package-lock/yarn.lock if applicable
            npm ci
            ;;

          python)
            need python
            need pip

            has_req=false
            has_pyproj=false
            has_setup=false
            has_poetry=false

            [[ -f "requirements.txt" ]] && has_req=true
            [[ -f "pyproject.toml" ]] && has_pyproj=true
            [[ -f "setup.py" ]] && has_setup=true
            [[ -f "poetry.lock" ]] && has_poetry=true

            if [[ "$has_req" == false && "$has_pyproj" == false && "$has_setup" == false && "$has_poetry" == false ]]; then
              die "No Python dependency file found (expected one of: requirements.txt, pyproject.toml, setup.py, poetry.lock)"
            fi

            # Prefer Poetry when detected
            if [[ "$has_poetry" == true || ( "$has_pyproj" == true && $(grep -Eiq '^\[tool\.poetry\]' pyproject.toml && echo yes || echo no) == "yes" ) ]]; then
              if ! command -v poetry >/dev/null 2>&1; then
                echo "â„¹ï¸ Poetry not found; attempting to install locally (pip)"
                pip install --user poetry || die "Failed to install Poetry"
                export PATH="$HOME/.local/bin:$PATH"
              fi
              poetry --version >/dev/null || die "Poetry installation unusable"
              # Install project deps; skip building the project itself if you prefer
              poetry install --no-interaction
            elif [[ "$has_req" == true ]]; then
              pip install -r requirements.txt
            elif [[ "$has_setup" == true || "$has_pyproj" == true ]]; then
              # PEP 517/518 or legacy setup.py
              # Use editable if you need live code changes; otherwise prefer a regular install
              pip install .
            else
              die "Could not determine a Python install strategy"
            fi
            ;;

          dotnet)
            need dotnet
            if ! find . -type f -name "*.csproj" | grep -q .; then
              die "No .csproj files found but project type is 'dotnet'"
            fi
            dotnet restore --nologo
            ;;

          java)
            if [[ -f "pom.xml" ]]; then
              need mvn
              mvn -B -ntp dependency:go-offline
            elif [[ -f "build.gradle" || -f "settings.gradle" || -f "build.gradle.kts" || -f "settings.gradle.kts" ]]; then
              if [[ -x "./gradlew" ]]; then
                ./gradlew build --no-daemon --refresh-dependencies
              else
                need gradle
                gradle build --no-daemon --refresh-dependencies
              fi
            else
              die "No pom.xml or Gradle build files found but project type is 'java'"
            fi
            ;;

          *)
            die "Unknown project type '${{ steps.detect.outputs.project_type }}'"
            ;;
        esac

        echo "âœ… Dependency setup completed."

    # =============== Build ===============
    - name: Build
      run: |
        set -euo pipefail

        project_type="${{ steps.detect.outputs.project_type || 'unknown' }}"

        case "$project_type" in
          node)
            # Build if a "build" script exists
            npm run build --if-present
            ;;

          dotnet)
            # Ensure restore happened earlier, or do it here
            dotnet restore || {
              echo "âŒ Error: .NET restore failed"
              exit 1
            }
            dotnet build || {
              echo "âŒ Error: .NET build failed"
              exit 1
            }
            ;;

          java)
            # Require either Maven (pom.xml) or Gradle (build.gradle)
            if [ ! -f pom.xml ] && [ ! -f build.gradle ]; then
              echo "âŒ Error: No pom.xml or build.gradle found for Java project"
              exit 1
            fi

            if [ -f pom.xml ]; then
              # Compile without tests; adjust goals as needed (e.g., package)
              mvn -B -DskipTests compile || {
                echo "âŒ Error: Maven compilation failed"
                exit 1
              }
            elif [ -f build.gradle ]; then
              if [ -f gradlew ]; then
                # Use wrapper; skip tests in CI builds
                ./gradlew build -x test || {
                  echo "âŒ Error: Gradle build failed"
                  exit 1
                }
              else
                echo "âŒ Error: build.gradle found but no gradlew wrapper."
                echo "ðŸ‘‰ Add the Gradle wrapper: 'gradle wrapper' and commit ./gradlew and wrapper files."
                exit 1
              fi
            fi
            ;;

          python)
            echo "â„¹ï¸  No explicit build step required for python"
            ;;

          *)
            echo "â„¹ï¸  No explicit build step required for '$project_type'"
            ;;
        esac

    # =============== Run Tests ===============
    - name: Run tests
      run: |
        set -euo pipefail

        project_type="${{ steps.detect.outputs.project_type || 'unknown' }}"

        if [[ -z "$project_type" ]]; then
          echo "âŒ Error: project_type is empty or not set."
          exit 1
        fi

        echo "â„¹ï¸  Detected project type: $project_type"

        case "$project_type" in
          node)
            # Ensure Node project structure
            if [[ ! -f package.json ]]; then
              echo "âŒ Error: package.json not found for Node.js tests"
              exit 1
            fi
            # Optional: ensure npm available
            if ! command -v npm >/dev/null 2>&1; then
              echo "âŒ Error: npm not found in PATH"
              exit 1
            fi

            echo "â–¶ï¸  Running npm test"
            npm test || {
              echo "âŒ Error: Node.js tests failed"
              exit 1
            }
            ;;

          python)
            # Optional: ensure Python available
            if ! command -v python >/dev/null 2>&1; then
              echo "âŒ Error: python not found in PATH"
              exit 1
            fi

            # Validate test configuration exists
            if [[ ! -f pytest.ini ]] && [[ ! -f setup.cfg ]] && \
              [[ ! -f pyproject.toml ]] && [[ ! -f "tests/__init__.py" ]] && \
              [[ ! -d tests ]]; then
              echo "âš ï¸  Warning: No pytest/unittest configuration found. Tests are required for production projects."
              echo "   Create one of: pytest.ini, setup.cfg, pyproject.toml, or tests/ directory"

              echo "â–¶ï¸  Attempting to run tests anyway (pytest, then unittest)"
              if command -v pytest >/dev/null 2>&1; then
                python -m pytest || {
                  echo "âŒ Error: No tests found or pytest failed. Please add tests to your Python project."
                  exit 1
                }
              else
                python -m unittest discover || {
                  echo "âŒ Error: No tests found. Please add tests to your Python project."
                  exit 1
                }
              fi
            else
              echo "â–¶ï¸  Running Python tests"
              if command -v pytest >/dev/null 2>&1; then
                python -m pytest || {
                  echo "âŒ Error: Python tests failed"
                  exit 1
                }
              else
                python -m unittest discover || {
                  echo "âŒ Error: Python tests failed"
                  exit 1
                }
              fi
            fi
            ;;

          dotnet)
            if ! command -v dotnet >/dev/null 2>&1; then
              echo "âŒ Error: dotnet SDK not found in PATH"
              exit 1
            fi

            echo "â–¶ï¸  Running dotnet test with coverage"
            dotnet test --no-build --verbosity normal \
              --logger "trx;LogFileName=test-results.trx" \
              --collect:"XPlat Code Coverage" \
              --results-directory ./TestResults || {
              echo "âŒ Error: .NET tests failed"
              exit 1
            }
            ;;

          java)
            # Detect build tool
            if [[ ! -f pom.xml ]] && [[ ! -f build.gradle ]]; then
              echo "âŒ Error: No pom.xml or build.gradle found for Java tests"
              exit 1
            fi

            if [[ -f pom.xml ]]; then
              if ! command -v mvn >/dev/null 2>&1; then
                echo "âŒ Error: Maven (mvn) not found in PATH"
                exit 1
              fi

              echo "â–¶ï¸  Running Maven tests"
              mvn -q -B test || {
                echo "âŒ Error: Maven tests failed"
                exit 1
              }
            elif [[ -f build.gradle ]]; then
              if [[ -x ./gradlew ]]; then
                echo "â–¶ï¸  Running Gradle wrapper tests"
                ./gradlew test || {
                  echo "âŒ Error: Gradle tests failed"
                  exit 1
                }
              else
                # Using system gradle is possible, but wrapper is recommended
                if command -v gradle >/dev/null 2>&1; then
                  echo "âš ï¸  Warning: gradle wrapper not found; using system gradle"
                  gradle test || {
                    echo "âŒ Error: Gradle tests failed"
                    exit 1
                  }
                else
                  echo "âŒ Error: build.gradle found but no gradlew wrapper and gradle not installed â€“ use Gradle wrapper"
                  exit 1
                }
              fi
            fi
            ;;

          *)
            echo "âŒ Error: No test command defined for project type: '$project_type'"
            exit 1
            ;;
        esac

        echo "âœ… Tests completed successfully for: $project_type"

    # =============== Upload Test Results ===============
    - name: Upload .NET test results
      if: always() && steps.detect.outputs.project_type == 'dotnet'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-dotnet-${{ runner.os }}
        path: |
          ./TestResults/
          **/coverage.cobertura.xml
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Node.js test results
      if: always() && steps.detect.outputs.project_type == 'node'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-node-${{ runner.os }}
        path: |
          coverage/
          __tests__/
          .nyc_output/
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Python test results
      if: always() && steps.detect.outputs.project_type == 'python'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-python-${{ runner.os }}
        path: |
          htmlcov/
          .coverage
          coverage.xml
          .pytest_cache/
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Java test results
      if: always() && steps.detect.outputs.project_type == 'java'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-java-${{ runner.os }}
        path: |
          target/surefire-reports/
          build/test-results/
          target/site/jacoco/
        retention-days: 30
        if-no-files-found: ignore

    - name: Check for test report files
      if: always()
      id: check-test-files
      run: |
        set -euo pipefail

        test_files_found=false

        # Find the first matching test report file (fast) and check if any output was produced
        if find . -type f \( -name '*.trx' -o -name '*.xml' \) -print -quit | grep -q .; then
          test_files_found=true
        else
          test_files_found=false
        fi

        echo "test_files_found=$test_files_found" >> "$GITHUB_OUTPUT"
        echo "Test report files found: $test_files_found"
    
    - name: Publish test results to GitHub Checks
      if: always() && steps.check-test-files.outputs.test_files_found == 'true'
      uses: dorny/test-reporter@v1
      with:
        name: Test Results - ${{ steps.detect.outputs.project_type }}
        path: |
          **/test-results/*.xml
          **/surefire-reports/*.xml
          **/TestResults/**/*.trx
        reporter: ${{ steps.detect.outputs.project_type == 'dotnet' && 'dotnet-trx' || steps.detect.outputs.project_type == 'java' && 'java-junit' || 'java-junit' }}
        fail-on-error: false