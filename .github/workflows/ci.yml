# .github/workflows/ci.yml
name: Build and Test

on:
  push:
    branches: [ main, master, develop, "feature/**" ]  # Runs on main release and feature branches
    tags: [ 'v*.*.*' ]  # Ensure CI runs for version tags too
  pull_request:
    branches: [ main, master, develop ]  # Also runs on PRs to main/master/develop
  workflow_dispatch:  # Allow manual triggering

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  DOTNET_VERSION: '10.0.x'
  JAVA_VERSION: '17'
  CURRENT_VERSION: '1.0.0'

jobs:
  validate-workflows:
    name: Validate Workflow Syntax
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate GitHub Actions workflows
      run: |
        echo "üìã Installing actionlint for workflow validation..."
        mkdir -p /tmp/actionlint
        cd /tmp/actionlint
        wget -q https://github.com/rhysd/actionlint/releases/download/v1.6.27/actionlint_linux_amd64.zip
        unzip -q actionlint_linux_amd64.zip
        chmod +x ./actionlint
        echo "‚úÖ Actionlint installed"
        
        echo "üìù Validating workflow files..."
        /tmp/actionlint/actionlint "${{ github.workspace }}/.github/workflows/"*.yml || {
          echo "‚ùå Workflow validation failed"
          exit 1
        }
        echo "‚úÖ All workflows are syntactically valid"

  scan-dependencies:
    name: Scan for Vulnerable Dependencies
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Detect project type
      id: detect
      run: |
        if [ -f package.json ]; then
          echo "project_type=node" >> $GITHUB_OUTPUT
        elif [ -f requirements.txt ] || [ -f pyproject.toml ]; then
          echo "project_type=python" >> $GITHUB_OUTPUT
        elif find . -name "*.csproj" -type f | grep -q .; then
          echo "project_type=dotnet" >> $GITHUB_OUTPUT
        elif [ -f pom.xml ] || [ -f build.gradle ]; then
          echo "project_type=java" >> $GITHUB_OUTPUT
        else
          echo "project_type=unknown" >> $GITHUB_OUTPUT
        fi

    # Node.js vulnerability scanning
    - name: Run npm audit (Node.js)
      if: ${{ steps.detect.outputs.project_type == 'node' }}
      run: |
        echo "üîç Scanning Node.js dependencies for vulnerabilities..."
        npm audit --audit-level=moderate || {
          echo "‚ö†Ô∏è  Vulnerabilities found. Run 'npm audit fix' to resolve."
          exit 1
        }

    # Python vulnerability scanning
    - name: Run pip-audit (Python)
      if: ${{ steps.detect.outputs.project_type == 'python' }}
      run: |
        echo "üîç Scanning Python dependencies for vulnerabilities..."
        pip install pip-audit > /dev/null 2>&1
        pip-audit --desc || echo "‚ö†Ô∏è  Review vulnerabilities above"

    # .NET vulnerability scanning
    - name: Run dotnet list package (dotnet)
      if: ${{ steps.detect.outputs.project_type == 'dotnet' }}
      run: |
        echo "üîç Scanning .NET dependencies for vulnerabilities..."
        dotnet tool install --global dotnet-outdated-tool > /dev/null 2>&1 || true
        dotnet outdated || echo "‚ö†Ô∏è  Review outdated packages above"

    # Java vulnerability scanning
    - name: Run dependency-check (Java)
      if: ${{ steps.detect.outputs.project_type == 'java' }}
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'Java Project'
        path: '.'
        format: 'JSON'
        args: >
          --enableExperimental
      continue-on-error: true

  build-test:
    name: Build and Test
    needs: [validate-workflows, scan-dependencies]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Detect project type
    - name: Detect project type
      id: detect
      run: |
        if [ -f package.json ]; then
          echo "project_type=node" >> $GITHUB_OUTPUT
        elif [ -f requirements.txt ] || [ -f pyproject.toml ]; then
          echo "project_type=python" >> $GITHUB_OUTPUT
        elif find . -name "*.csproj" -type f | grep -q .; then
          echo "project_type=dotnet" >> $GITHUB_OUTPUT
        elif [ -f pom.xml ] || [ -f build.gradle ]; then
          echo "project_type=java" >> $GITHUB_OUTPUT
          if [ -f pom.xml ]; then
            echo "java_cache=maven" >> $GITHUB_OUTPUT
          else
            echo "java_cache=gradle" >> $GITHUB_OUTPUT
          fi
        else
          echo "project_type=unknown" >> $GITHUB_OUTPUT
        fi

    # =============== Node.js ===============
    - name: Set up Node.js and cache npm
      if: steps.detect.outputs.project_type == 'node'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: |
          **/package-lock.json
          **/yarn.lock
          **/pnpm-lock.yaml

    # =============== Python ===============
    - name: Set up Python and cache pip
      if: steps.detect.outputs.project_type == 'python'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: |
          **/requirements.txt
          **/pyproject.toml
          **/setup.py
          **/poetry.lock

    # =============== .NET ===============
    - name: Set up .NET
      if: steps.detect.outputs.project_type == 'dotnet'
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # .NET projects benefit from caching the ~/.nuget/packages folder
    - name: Cache NuGet packages
      if: steps.detect.outputs.project_type == 'dotnet'
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/obj/project.assets.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    # Calculate build version for .NET
    - name: Calculate .NET version
      if: steps.detect.outputs.project_type == 'dotnet'
      id: dotnet-version
      run: |
        BUILD_NUMBER=${{ github.run_number }}
        VERSION="${{ env.CURRENT_VERSION }}.$BUILD_NUMBER"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Building with version: $VERSION"

    # =============== Java ===============
    - name: Set up Java and cache Maven/Gradle
      if: steps.detect.outputs.project_type == 'java'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: ${{ steps.detect.outputs.java_cache }}

    # Note: setup-java@v4 auto-caches Maven/Gradle using hashFiles() internally when `cache:` is set.
    # So no extra cache step is needed for Java.

    # =============== Install Dependencies ===============
    - name: Install dependencies
      run: |
        case "${{ steps.detect.outputs.project_type }}" in
          node)
            if [ ! -f package.json ]; then
              echo "‚ùå Error: package.json not found but detected as Node.js project"
              exit 1
            fi
            npm ci
            ;;
          python)
            if [ ! -f requirements.txt ] && [ ! -f pyproject.toml ] && [ ! -f setup.py ] && [ ! -f poetry.lock ]; then
              echo "‚ùå Error: No Python dependency file found (requirements.txt, pyproject.toml, setup.py, or poetry.lock required)"
              exit 1
            fi
            pip install -r requirements.txt 2>/dev/null || pip install -e . || {
              echo "‚ùå Error: Failed to install Python dependencies"
              exit 1
            }
            ;;
          dotnet)
            if ! find . -name "*.csproj" -type f | grep -q .; then
              echo "‚ùå Error: No .csproj files found but detected as .NET project"
              exit 1
            fi
            dotnet restore
            ;;
          java)
            if [ ! -f pom.xml ] && [ ! -f build.gradle ]; then
              echo "‚ùå Error: No pom.xml or build.gradle found but detected as Java project"
              exit 1
            fi
            if [ -f pom.xml ]; then
              mvn dependency:go-offline
            elif [ -f build.gradle ]; then
              ./gradlew dependencies || gradle dependencies
            fi
            ;;
          *)
            echo "‚ùå Error: Unknown project type"
            exit 1
            ;;
        esac

    # =============== Build ===============
    - name: Build
      run: |
        case "${{ steps.detect.outputs.project_type }}" in
          node)
            npm run build --if-present
            ;;
          dotnet)
            VERSION="${{ steps.dotnet-version.outputs.version }}"
            dotnet build --no-restore \
              /p:Version=$VERSION \
              /p:AssemblyVersion=$VERSION \
              /p:FileVersion=$VERSION \
              /p:InformationalVersion=$VERSION || {
              echo "‚ùå Error: .NET build failed"
              exit 1
            }
            ;;
          java)
            if [ ! -f pom.xml ] && [ ! -f build.gradle ]; then
              echo "‚ùå Error: No pom.xml or gradlew found for Java project"
              exit 1
            fi
            if [ -f pom.xml ]; then
              mvn compile || {
                echo "‚ùå Error: Maven compilation failed"
                exit 1
              }
            elif [ -f build.gradle ]; then
              if [ -f gradlew ]; then
                ./gradlew build -x test || {
                  echo "‚ùå Error: Gradle build failed"
                  exit 1
                }
              else
                echo "‚ùå Error: build.gradle found but no gradlew wrapper - use gradle wrapper (gradlew)"
                exit 1
              fi
            fi
            ;;
          python|*)
            echo "‚ÑπÔ∏è  No explicit build step required for ${{ steps.detect.outputs.project_type }}"
            ;;
        esac

    # =============== Run Tests ===============
    - name: Run tests
      run: |
        case "${{ steps.detect.outputs.project_type }}" in
          node)
            if [ ! -f package.json ]; then
              echo "‚ùå Error: package.json not found for Node.js tests"
              exit 1
            fi
            npm test || {
              echo "‚ùå Error: Node.js tests failed"
              exit 1
            }
            ;;
          python)
            # Validate test configuration exists
            if [ ! -f pytest.ini ] && [ ! -f setup.cfg ] && [ ! -f pyproject.toml ] && [ ! -f "tests/__init__.py" ] && [ ! -d tests ]; then
              echo "‚ö†Ô∏è  Warning: No pytest/unittest configuration found. Tests are required for production projects."
              echo "Create one of: pytest.ini, setup.cfg, pyproject.toml, or tests/ directory"
              # Try to run tests anyway
              python -m pytest 2>/dev/null || python -m unittest discover 2>/dev/null || {
                echo "‚ùå Error: No tests found. Please add tests to your Python project."
                exit 1
              }
            else
              python -m pytest 2>/dev/null || python -m unittest discover || {
                echo "‚ùå Error: Python tests failed"
                exit 1
              }
            fi
            ;;
          dotnet)
            dotnet test --no-build --verbosity normal --logger trx --collect:"XPlat Code Coverage" --results-directory ./TestResults || {
              echo "‚ùå Error: .NET tests failed"
              exit 1
            }
            ;;
          java)
            if [ ! -f pom.xml ] && [ ! -f build.gradle ]; then
              echo "‚ùå Error: No pom.xml or build.gradle found for Java tests"
              exit 1
            fi
            if [ -f pom.xml ]; then
              mvn test || {
                echo "‚ùå Error: Maven tests failed"
                exit 1
              }
            elif [ -f build.gradle ]; then
              if [ -f gradlew ]; then
                ./gradlew test || {
                  echo "‚ùå Error: Gradle tests failed"
                  exit 1
                }
              else
                echo "‚ùå Error: build.gradle found but no gradlew wrapper - use gradle wrapper"
                exit 1
              fi
            fi
            ;;
          *)
            echo "‚ùå Error: No test command defined for project type"
            exit 1
            ;;
        esac

    # =============== Upload Test Results ===============
    - name: Upload .NET test results
      if: always() && steps.detect.outputs.project_type == 'dotnet'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-dotnet-${{ runner.os }}
        path: |
          ./TestResults/
          **/coverage.cobertura.xml
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Node.js test results
      if: always() && steps.detect.outputs.project_type == 'node'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-node-${{ runner.os }}
        path: |
          coverage/
          __tests__/
          .nyc_output/
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Python test results
      if: always() && steps.detect.outputs.project_type == 'python'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-python-${{ runner.os }}
        path: |
          htmlcov/
          .coverage
          coverage.xml
          .pytest_cache/
        retention-days: 30
        if-no-files-found: ignore

    - name: Upload Java test results
      if: always() && steps.detect.outputs.project_type == 'java'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-java-${{ runner.os }}
        path: |
          target/surefire-reports/
          build/test-results/
          target/site/jacoco/
        retention-days: 30
        if-no-files-found: ignore

    - name: Publish test results to GitHub Checks
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Test Results - ${{ steps.detect.outputs.project_type }}
        path: |
          **/test-results/*.xml
          **/surefire-reports/*.xml
          **/TestResults/*.trx
        reporter: java-junit
        fail-on-error: false